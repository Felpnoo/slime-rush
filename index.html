<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slime Rush Evolution</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #050505; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: sans-serif; }
        canvas { box-shadow: 0 0 30px rgba(0, 255, 150, 0.15); border: 1px solid #1f1f1f; border-radius: 12px; }
    </style>
</head>
<body>
<script>
const SETTINGS = {
    EASY:   { label: "FÁCIL",   max: 1, tripleChance: 0,    speed: 1000, color: '#00ff96' },
    MEDIUM: { label: "MÉDIO",   max: 2, tripleChance: 0.08, speed: 800,  color: '#00d4ff' },
    HARD:   { label: "DIFÍCIL", max: 3, tripleChance: 0.25, speed: 600,  color: '#ff007a' }
};

class MenuScene extends Phaser.Scene {
    constructor() { super('MenuScene'); }
    preload() {
        this.load.setCORS('anonymous');
        this.load.baseURL = 'assets/';
        // Carrega apenas os que você tem (1 ao 6)
        for (let i = 1; i <= 6; i++) {
            this.load.image(`slime_${i}`, `slime_${i}.png`);
        }
    }
    create() {
        this.add.text(225, 180, 'SLIME RUSH', { fontSize: '48px', fill: '#00ff96', fontStyle: 'bold', stroke: '#000', strokeThickness: 6 }).setOrigin(0.5);
        this.add.text(225, 230, 'EVOLUTION', { fontSize: '24px', fill: '#fff', letterSpacing: 10 }).setOrigin(0.5);

        ['EASY', 'MEDIUM', 'HARD'].forEach((diff, i) => {
            let config = SETTINGS[diff];
            let btnBg = this.add.rectangle(225, 450 + (i * 85), 280, 60, 0x111111).setInteractive({ useHandCursor: true });
            let btnText = this.add.text(225, 450 + (i * 85), config.label, { fontSize: '24px', fill: config.color, fontStyle: 'bold' }).setOrigin(0.5);
            
            btnBg.setStrokeStyle(2, 0x333333);
            btnBg.on('pointerdown', () => this.scene.start('MainScene', { difficulty: diff }));
            btnBg.on('pointerover', () => { btnBg.setStrokeStyle(3, parseInt(config.color.replace('#','0x'))); btnText.setScale(1.1); });
            btnBg.on('pointerout', () => { btnBg.setStrokeStyle(2, 0x333333); btnText.setScale(1.0); });
        });
    }
}

class MainScene extends Phaser.Scene {
    constructor() { super('MainScene'); }
    init(data) {
        this.diff = SETTINGS[data.difficulty || 'MEDIUM'];
        this.score = 0;
        this.grid = Array(4).fill().map(() => Array(4).fill(null));
    }
    create() {
        // Grid Visual Moderno
        const graphics = this.add.graphics();
        graphics.lineStyle(2, 0x1f1f1f);
        for(let r=0; r<4; r++) {
            for(let c=0; c<4; c++) {
                graphics.strokeRoundedRect(c * 105 + 25, r * 105 + 200, 95, 95, 10);
            }
        }

        this.slimes = this.add.group();
        this.spawnSlime(2);
        
        this.scoreText = this.add.text(225, 80, '0', { fontSize: '80px', fill: '#fff', fontStyle: 'bold', alpha: 0.2 }).setOrigin(0.5);
        
        // Tecla T para o Trailer (NixOS/Hyprland)
        this.input.keyboard.on('keydown-T', () => this.startTrailer());
    }

    spawnSlime(forced = null) {
        let slots = this.getEmpty();
        if (slots.length === 0) return this.scene.start('MenuScene');

        let count = forced || 1;
        if (!forced) {
            let roll = Math.random();
            if (this.diff.max === 3 && roll < this.diff.tripleChance) count = 3;
            else if (this.diff.max >= 2 && roll > 0.6) count = 2;
        }

        count = Math.min(count, slots.length);
        for (let i = 0; i < count; i++) {
            let slot = Phaser.Utils.Array.GetRandom(this.getEmpty());
            if (slot) this.addSlime(slot.r, slot.c, Math.random() > 0.9 ? 2 : 1);
        }
    }

    addSlime(r, c, lvl) {
        let x = c * 105 + 72.5;
        let y = r * 105 + 247.5;
        
        // Se a imagem não existe (lvl > 6), desenha um círculo colorido
        let s;
        if (lvl > 6) {
            s = this.add.circle(x, y, 40, 0xff007a).setStrokeStyle(4, 0xffffff);
        } else {
            s = this.add.image(x, y, `slime_${lvl}`).setDisplaySize(85, 85);
        }

        s.level = lvl; s.gridR = r; s.gridC = c;
        this.grid[r][c] = s;
        s.setScale(0);
        this.tweens.add({ targets: s, scale: 1, duration: 300, ease: 'Back.out' });
    }

    merge(s1, s2) {
        let nLvl = s1.level + 1;
        this.cameras.main.shake(150, 0.005);
        
        this.grid[s1.gridR][s1.gridC] = null;
        s1.destroy();
        
        // Atualiza s2 para o novo nível
        s2.level = nLvl;
        if (nLvl <= 6) {
            s2.setTexture(`slime_${nLvl}`).setDisplaySize(85, 85);
        } else {
            // Fallback visual para níveis sem imagem (2048 etc)
            s2.destroy();
            this.addSlime(s2.gridR, s2.gridC, nLvl);
        }

        this.score += Math.pow(2, nLvl);
        this.scoreText.setText(this.score);
        this.time.delayedCall(200, () => this.spawnSlime());
    }

    startTrailer() {
        this.cameras.main.zoomTo(1.1, 2000, 'Cubic.easeInOut');
        this.time.addEvent({
            delay: 700,
            callback: () => {
                let moved = false;
                for(let r=0; r<4; r++) {
                    for(let c=0; c<4; c++) {
                        let s1 = this.grid[r][c];
                        if (!s1) continue;
                        [[0,1],[1,0]].forEach(([dr, dc]) => {
                            let nr = r+dr, nc = c+dc;
                            if(nr<4 && nc<4 && !moved) {
                                let s2 = this.grid[nr][nc];
                                if(s2 && s2.level === s1.level) { this.merge(s1, s2); moved = true; }
                            }
                        });
                    }
                }
                if(!moved) this.spawnSlime();
            },
            loop: true
        });
    }

    getEmpty() {
        let e = [];
        for(let r=0; r<4; r++) for(let c=0; c<4; c++) if(!this.grid[r][c]) e.push({r,c});
        return e;
    }
}

const config = {
    type: Phaser.AUTO,
    width: 450, height: 800,
    backgroundColor: '#050505',
    parent: 'game-container',
    scene: [MenuScene, MainScene]
};
new Phaser.Game(config);
</script>
</body>
</html>
